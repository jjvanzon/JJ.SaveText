// *
// * Copyright (C) 2005 Roger Alsing : http://www.puzzleframework.com
// *
// * This library is free software; you can redistribute it and/or modify it
// * under the terms of the GNU Lesser General Public License 2.1 or later, as
// * published by the Free Software Foundation. See the included license.txt
// * or http://www.gnu.org/copyleft/lesser.html for details.
// *
// *

using System;
using System.Collections;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;

namespace Puzzle.NAspect.Framework
{
    /// <summary>
    /// Cache used by the emitter to store various lookup values.
    /// There is actually not a single person alive that knows exactly what these lists hold.
    /// It has been long forgotten by the ancients.
    /// </summary>
    public class MethodCache
    {
        /// <summary>
        /// Contains an arraylist of affected mixins for a proxytype
        /// </summary>
        public static Hashtable mixinsLookup = new Hashtable();

        /// <summary>
        /// Contains an arraylist of affected aspects for a proxytype
        /// </summary>
        public static Hashtable aspectsLookup = new Hashtable();

        /// <summary>
        /// Contains an arraylist of affected methods for a proxytype
        /// </summary>
        public static Hashtable methodsLookup = new Hashtable();

        /// <summary>
        /// Contains the base methodinfo for each methodid (wrappername)
        /// </summary>
        public static Hashtable methodLookup = new Hashtable();

        /// <summary>
        /// Contains the wrapper methodinfo for each methodid(wrappername)
        /// </summary>
        public static Hashtable wrapperMethodLookup = new Hashtable();

        /// <summary>
        /// Contains an arraylist of interceptors for each methodId (wrappername)
        /// </summary>
        public static Hashtable methodInterceptorsLookup = new Hashtable();

        /// <summary>
        /// Gets the interceptors associated with a unique methodId
        /// </summary>
        /// <param name="methodId">unique methodId generated by the proxy emitter.</param>
        /// <returns>List of IInterceptors and BeforeDelegate , AroundDelegate and AfterDelegates</returns>
        [DebuggerStepThrough()]
        public static IList GetInterceptors(string methodId)
        {
            if (methodId == null)
                throw new NullReferenceException("Method may not be null");


            if (methodInterceptorsLookup.Contains(methodId))
            {
                IList methodinterceptors = methodInterceptorsLookup[methodId] as IList;
                return methodinterceptors;
            }

            throw new Exception("Unknown method");
        }

        //used by the explicit iface proyfier
        /// <summary>
        /// 
        /// </summary>
        public static MethodInfo GetMethodMethodInfo = typeof (MethodCache).GetMethod("GetMethod");

        /// <summary>
        /// 
        /// </summary>
        /// <param name="methodId"></param>
        /// <returns></returns>
        [DebuggerStepThrough()]
        public static MethodBase GetMethod(string methodId)
        {
            return (MethodBase) methodLookup[methodId];
        }



        private static Hashtable callInfoMapper = new Hashtable();
        private static ArrayList callInfos = new ArrayList();
        [DebuggerStepThrough()]
        [DebuggerHidden()]
        internal static CallInfo GetCallInfo(int methodIndex)
        {
            return (CallInfo)callInfos[methodIndex];
        }

        [DebuggerStepThrough()]
        [DebuggerHidden()]
        internal static CallInfo GetCallInfo(string methodId)
        {
            return (CallInfo)callInfoMapper[methodId];
        }
        
        internal static int AddCallInfo(CallInfo callInfo, string methodId)
        {
            int res;
            lock(callInfos.SyncRoot)
            {
                res = callInfos.Add(callInfo);
                callInfoMapper[methodId] = callInfo;
            }
            return res;
        }

        internal static CallInfo CreateCallInfo(MethodInfo method, ParameterInfo[] parameterInfos, string wrapperName)
        {
            InvocationParameterInfo[] parameters = new InvocationParameterInfo[parameterInfos.Length];
            for (int i = 0; i < parameterInfos.Length; i++)
            {
                ParameterInfo paramInfo = parameterInfos[i];
                Type paramType = paramInfo.ParameterType;
                if (paramType.IsByRef)
                    paramType = paramType.GetElementType();

                InvocationParameterInfo invocationParamInfo = new InvocationParameterInfo(paramInfo.Name, i, paramType, ParameterType.ByVal);
                parameters[i]=invocationParamInfo;
            }

#if NET2
            return new CallInfo(wrapperName, method, new ArrayList(), parameters, FastCall.GetMethodInvoker(method));
#else
			return new CallInfo(wrapperName,method, new ArrayList(),parameters);
#endif
        }

        internal static CallInfo CreateCallInfoForCtor(ConstructorInfo method, ParameterInfo[] parameterInfos, string wrapperName)
        {
            InvocationParameterInfo[] parameters = new InvocationParameterInfo[parameterInfos.Length+1];
            parameters[0] = new InvocationParameterInfo("_state", 0, typeof(object), ParameterType.ByVal);
            for (int i = 0; i < parameterInfos.Length; i++)
            {
                ParameterInfo paramInfo = parameterInfos[i];
                Type paramType = paramInfo.ParameterType;
                if (paramType.IsByRef)
                    paramType = paramType.GetElementType();

                InvocationParameterInfo invocationParamInfo = new InvocationParameterInfo(paramInfo.Name, i + 1, paramType, ParameterType.ByVal);
                parameters[i+1] = invocationParamInfo;
            }

#if NET2
            return new CallInfo(wrapperName, method, new ArrayList(), parameters, FastCall.GetMethodInvoker(method));
#else
			return new CallInfo(wrapperName,method, new ArrayList(),parameters);
#endif
        }


        internal static void CopyBackRefParams(ILGenerator il, ParameterInfo[] parameterInfos, LocalBuilder paramList)
        {
            int j;
            j = 0;
            foreach (ParameterInfo parameter in parameterInfos)
            {
                if (parameter.ParameterType.IsByRef)
                {
                    il.Emit(OpCodes.Ldarg, j + 1);
                    il.Emit(OpCodes.Ldloc, paramList);
                    il.Emit(OpCodes.Ldc_I4, j);
                    il.Emit(OpCodes.Ldelem_Ref);
                    Type t = parameter.ParameterType.GetElementType();
                    if (t.IsValueType)
                    {
                        il.Emit(OpCodes.Unbox, t);
                        il.Emit(OpCodes.Ldobj, t);
                        il.Emit(OpCodes.Stobj, t);
                    }
                    else
                    {
                        il.Emit(OpCodes.Castclass, t);
                        il.Emit(OpCodes.Stind_Ref);
                    }
                }
                j++;
            }
        }
    }
    
    
}